file.name = "no_axis_viridis2.mp4", colbg = "black",
speed = 1, axis.type = "none", loop = 3)
scrolling_spectro(wave = wv, wl = 150,
t.display = 1.2, ovlp = 95, pal = magma,
grid = FALSE, flim = c(1, 10), width = 1000,
height = 500, res = 120, collevels = seq(-40, 0, 5),
file.name = "3397_SUR_03-Feb_2021_08.06_10.57_A56-11_v5.mp4", colbg = "black",
speed = 0.5, axis.type = "none", loop = 3)
scrolling_spectro(wave = Phae.long4, wl = 300,
t.display = 1.7, ovlp = 90, pal = magma,
grid = FALSE, flim = c(1, 10), width = 1000,
height = 500, res = 120, collevels = seq(-40, 0, 5),
file.name = "Phae.long4.mp4", colbg = "black",
speed = 0.2, axis.type = "none", loop = 3)
scrolling_spectro(wave = Phae.long4, wl = 300,
t.display = 1.7, ovlp = 90, pal = magma,
grid = FALSE, flim = c(1, 10), width = 1000,
height = 500, res = 120, collevels = seq(-40, 0, 5),
file.name = "Phae.long4.mp4", colbg = "black",
speed = 1, axis.type = "minimal", loop = 3)
scrolling_spectro(wave = Phae.long4, wl = 300,
t.display = 1.7, ovlp = 90, pal = viridis,
grid = FALSE, flim = c(1, 10), width = 1000,
height = 500, res = 120, collevels = seq(-40, 0, 5),
file.name = "Phae.long4_viridis.mp4", colbg = "black",
speed = 1, axis.type = "minimal", loop = 3)```
scrolling_spectro(wave = Phae.long4, wl = 300,
t.display = 1.7, ovlp = 90, pal = viridis,
grid = FALSE, flim = c(1, 10), width = 1000,
height = 500, res = 120, collevels = seq(-40, 0, 5),
file.name = "Phae.long4_viridis.mp4", colbg = "black",
speed = 1, axis.type = "minimal", loop = 3)
spectro(Phae.long4)
Phae.long4.2 <- cutw(Phae.long4, from = 0, to = 2.8, output = "Wave")
scrolling_spectro(wave = Phae.long4.2, wl = 300,
t.display = 1.7, ovlp = 90, pal = viridis,
grid = FALSE, flim = c(1, 10), width = 1000,
height = 500, res = 120, collevels = seq(-40, 0, 5),
file.name = "Phae.long4_viridis.mp4", colbg = "black",
speed = 1, axis.type = "minimal", loop = 5)
# Chunk 1: Load packages
## vector with package names
x <- c( "pbapply", "parallel", "ggplot2", "warbleR", "Rraven", "viridis", "readxl", "rptR", "MCMCglmm", "MuMIn", "corrplot", "lme4", "grid", "gridExtra", "dynaSpec")
aa <- lapply(x, function(y) {
# check if installed, if not then install
if (!y %in% installed.packages()[,"Package"])
install.packages(y)
# load package
try(require(y, character.only = T), silent = T)
})
# Chunk 2: functions and parameters
#functions and parameters
knitr::opts_knit$set(root.dir = normalizePath(".."))
knitr::opts_chunk$set(dpi = 50, fig.width = 12, warning = FALSE, message = FALSE)
# ggplot2 theme
# theme_set(theme_classic(base_size = 20))
cut_path <- "./data/raw/cuts"
treatments <- c("Calibration", "Regular_singing", "Coordination", "After_chase",
"Before_playback", "After_playback", "Before_interaction", "After_interaction", "Before_noise", "After_noise")
# iterations for MCMCglmm models
itrns <- 100000
# functions from https://rdrr.io/rforge/rptR/src/R/rpt.mcmcLMM.R
rpt.mcmcLMM <- function(y, groups, CI=0.95, prior=NULL, verbose=FALSE, ...){
# initial checks
if(length(y)!= length(groups)) stop("y and group are of unequal length")
# preparation
groups <- factor(groups)
if(is.null(prior)) prior <- list(R=list(V=1,n=10e-2), G=list(G1=list(V=1,n=10e-2)) )
# point estimation according to model 8 and equation 9
mod   <- MCMCglmm(y ~ 1, random=~groups, family="gaussian", data=data.frame(y=y,groups=groups), prior=prior, verbose=verbose, ...)
var.a <- mod$VCV[,"groups"]
var.e <- mod$VCV[,"units"]
postR <- var.a / (var.a + var.e)
# point estimate
R     <- posterior.mode( postR )
# credibility interval estimation from paterior distribution
CI.R    <- coda::HPDinterval(postR,CI)[1,]
se 	    <- sd(postR)
# 'significance test'
P 	  <- NA
res = list(call=match.call(), datatype="Gaussian", method="LMM.MCMC", CI=CI,
R=R, CI.R=CI.R, se=se, P=P)
# class(res) <- "rpt"
return(res)
}
## print Gelman-Rubin convergence statistics, plots traces and autocorrelations
mcmc_diagnostics <- function(rep_mods_list){
for(w in 1:length(rep_mods_list))
{
mod_name <- names(rep_mods_list)[w]
if(mod_name == "1") mod_name <- "Null"
print(paste("model:", mod_name))
Y <- lapply(rep_mods_list[[w]], "[[", "Sol")
## add global plots and gelman test
# gelman_diagnostic
gel_diag <- as.data.frame(gelman.diag(mcmc.list(Y))$psrf)
# add estimate as column
gel_diag$estimate <- rownames(gel_diag)
# reorder columns
gel_diag <- gel_diag[, c(3, 1, 2)]
par(mfrow = c(1, 1))
# plot table
grid.newpage()
grid.draw(tableGrob(gel_diag, rows = NULL, theme=ttheme_default(base_size = 25)))
par(mfrow = c(1, 4))
traceplot(Y, col = adjustcolor(c("yellow","blue", "red"), alpha.f = 0.6))
autocorr.plot(x = Y[[1]], auto.layout = FALSE, lwd =4, col = "red")
}
}
# Chunk 3: read data
amp <- read.csv("./output/calibrated_amplitude_all_songs.csv")
amp$Treatment[amp$Treatment == "Regular_sining"] <- "Regular_singing"
# Chunk 5: repeatability plot
repts_df <- read.csv("./output/repeatability_optimization.csv")
pd <- position_dodge(width = 0.1)
ggplot(data = repts_df, aes(x = 1 - max_quantile, y = repeatability, color = only.low.outliers, group = only.low.outliers)) +
geom_hline(yintercept = 0.5, col = adjustcolor("red", alpha.f = 0.5)) +
geom_point(size = 2, position = pd) +
geom_errorbar(width=.05, aes(ymin = lowCI, ymax = hiCI), position = pd) +
scale_color_viridis(discrete = TRUE, begin = 0.2, end = 0.8, alpha = 0.7) +
geom_line(position = pd) +
labs(y = "Repeatability",  x = "Upper quantile used") +
ylim(c(0, 1)) + xlim(c(1, 0)) +
facet_wrap(~ outliers, scales = "fixed") +
theme_classic(base_size = 24)
repts_df$range <- repts_df$hiCI - repts_df$lowCI
# repts_df[order(repts_df$repeatability), c("max_quantile", "outliers", "only.low.outliers", "repeatability", "range")]
repts_df <- repts_df[order(repts_df$repeatability, decreasing = TRUE), ]
kable(head(repts_df))
# Chunk 6: repetability plot for presentation
# keep only morning recs, only regular singing and only from 2021
amp_morn <- amp[amp$period == "morning" & amp$year == 2021 & amp$Treatment == "Regular_singing", ]
# keep only males recorded at least twice
# count_sf <- table(amp_morn$ID[!duplicated(amp_morn$org.sound.file)])
amp_morn_rep <- amp_morn[amp_morn$ID %in% names(count_sf)[count_sf > 1], ]
amp_morn_rep <- amp_morn
quant_subet <- lapply(unique(amp_morn_rep$org.sound.file), function(y){
X <- amp_morn_rep[amp_morn_rep$org.sound.file == y, ]
# remove outliers
outlier_quant <- quantile(X$cal.spl, c(0.1, 1- 0.1))
X <- X[X$cal.spl >= outlier_quant[1],]
# quantlie for each max quantile
quant <- quantile(X$cal.spl, probs = 1 - 0.4)
# subset
X <- X[X$cal.spl >= quant, ]
})
quant_subet <- do.call(rbind, quant_subet)
ggplot(quant_subet, aes(x = factor(ID), y = cal.spl, width = 2)) +
geom_violin(fill = viridis(10)[8])+
theme_classic(base_size = 30) +
labs(x = "Individual", y = "Sound pressure level (dB)") +
theme(axis.text.x = element_text(angle = 90))
ggsave("./output/individual_differences_in_spl.jpeg", width = 14, height = 7)
# Chunk 7: apply subseting based on repeatability
# compose variable to remove low values and outliers based on repeatabiliy
amp$osf.treat <- paste(amp$org.sound.file, amp$Treatment, sep = "-")
rm_outlier_amp_l <- lapply(unique(amp$osf.treat), function(y){
X <- amp[amp$osf.treat == y, ]
# remove outliers
outlier_quant <- quantile(X$cal.spl, c(repts_df$outliers[1], 1))
X <- X[X$cal.spl >= outlier_quant[1] & X$cal.spl <= outlier_quant[2],]
# quantlie for each max quantile (0.6 was selected due to high repeatability)
quant <- quantile(X$cal.spl, probs = repts_df$max_quantile[1])
# subset
X <- X[X$cal.spl >= quant, ]
})
rm_outlier_amp <- do.call(rbind, rm_outlier_amp_l)
# Chunk 9: SPL vs period model selection
attach(readRDS("./output/mcmcglmm_period_models.RDS"))
mod_list <- lapply(period_mods, "[[", 1)
names(mod_list) <- gsub("cal.spl ~ ", "", period_formulas)
model_selection <- model.sel(mod_list, rank="DIC")
model_selection
# Chunk 10: SPL vs period effect size
# fixed effects with HPD intervals
best_mod_period <- period_mods[[which(names(period_mods) == row.names(model_selection)[1])]][[1]]
sm <- as.data.frame(summary(best_mod_period)$solutions[, -5])
sm
# Chunk 11: plot best model period
dat_period <- rm_outlier_amp[rm_outlier_amp$Treatment == "Regular_singing" & rm_outlier_amp$ID %in% unique(rm_outlier_amp$ID[rm_outlier_amp$period == "afternoon"]), ]
dat_period$period <- factor(dat_period$period, levels = c("morning", "afternoon"))
ggplot(dat_period, aes(x = as.factor(ID), y = cal.spl, color = period, fill = period)) +
geom_violin(position =  pd) +
labs(x = "Individual", y = "Sound pressure level (dB)", fill = "Period") +
scale_color_viridis_d(begin = 0.1, end = 0.8, alpha = 0.6) +
scale_fill_viridis_d(begin = 0.1, end = 0.8, alpha = 0.6) +
guides(color = FALSE) +
theme_classic(base_size = 24)
# Chunk 12: Effect size posterior distribution period
# simplify names
colnames(best_mod_period$Sol) <- c("Intercept", "Morning vs afternoon")
# stack posteriors
Y <- stack(as.data.frame(best_mod_period$Sol[, -1]))
Y$ind <- "Morning vs afternoon"
# plot posteriors
ggplot(Y, aes(y=values, x = ind)) +
geom_hline(yintercept = 0, col = "red", lty = 2) +
geom_violin(color = "gray40", fill = viridis(n = 1, alpha = 0.25, begin = 0.4)) +
labs(y = "Effect size posterior distribution",x = "Predictor") +
theme_classic(base_size = 24) +
theme(axis.text.x = element_text(angle = 45,  vjust = 0.9, hjust=1))
# Chunk 13: SPL vs condition
caps <- read_excel("/home/m/Dropbox/LBH data/Additional data files/LBH captures data.xlsx")
# same variables as in paper on spatial memory and body size
size_vars <- caps[caps$`Bird ID` %in% amp$ID, c("Bird ID", "Total culmen", "Flattened wing length", "Weight", "Central rectriz")]
# replace 419 central rectriz with mean
size_vars$`Central rectriz`[size_vars$`Bird ID` == 419] <- mean(size_vars$`Central rectriz`, na.rm = TRUE)
cor(size_vars[, c("Total culmen", "Flattened wing length", "Weight", "Central rectriz")], use = "pairwise.complete.obs")
# Chunk 14: SPL vs condition 2
mean_size <- aggregate(. ~ `Bird ID`, data = size_vars, FUN = mean, na.action = "na.omit")
pca <- prcomp(mean_size[, c("Total culmen", "Flattened wing length", "Weight", "Central rectriz")], scale. = TRUE)
summary(pca)
mean_size$PC1 <- pca$x[, 1]
rm_outlier_amp$PC1 <- sapply(1:nrow(rm_outlier_amp), function(x) mean_size$PC1[mean_size$`Bird ID` == rm_outlier_amp$ID[x]][1])
rm_outlier_amp$weight <- sapply(1:nrow(rm_outlier_amp), function(x) mean_size$Weight[mean_size$`Bird ID` == rm_outlier_amp$ID[x]][1])
### add weight lifted
lift <- read_excel("/home/m/Dropbox/LBH data/Morphology-condition/other files/Uplift power experiment.xlsx", sheet = "Results")
rm_outlier_amp$lift.weight <- sapply(1:nrow(rm_outlier_amp), function(x){
if(rm_outlier_amp$ID[x] == 0) weight <- NA else {
if (rm_outlier_amp$year[x] == 2019)
sub_lift <- lift[grep("\\.2019\\.", lift$Video), ] else
sub_lift <- lift[grep("\\.2021\\.", lift$Video), ]
weights <- sub_lift$Weight[sub_lift$ID == rm_outlier_amp$ID[x]]
if (length(weights) > 0)
# get the mean of the 2 highest flights
weight <- mean(sort(weights, decreasing = TRUE)[1:2]) else
weight <- NA
}
return(weight)
})
# Chunk 16: SPL vs body condition model selection
attach(readRDS("./output/mcmcglmm_size_models.RDS"))
mod_list <- lapply(size_mods, "[[", 1)
names(mod_list) <- gsub("cal.spl ~ ", "", size_formulas)
model_selection <- model.sel(mod_list, rank="DIC")
model_selection
# Chunk 17: SPL vs body condition effect size
# fixed effects with HPD intervals
best_mod_size <- size_mods[[which(names(size_mods) ==  "lift.weight + PC1")]][[1]]
sm_size <- as.data.frame(summary(best_mod_size)$solutions[, -5])
sm_size
# Chunk 18: SPL vs body condition plot
body_size_data <- rm_outlier_amp[rm_outlier_amp$Treatment == "Regular_singing" & rm_outlier_amp$year == 2021 & !is.na(rm_outlier_amp$PC1) & !is.na(rm_outlier_amp$lift.weight) & rm_outlier_amp$period == "morning", ]
agg_size <- aggregate(cbind(cal.spl, lift.weight, PC1) ~ ID, data = body_size_data, mean)
agg_size$count <- aggregate(PC1 ~ ID, data = body_size_data, length)$PC1
ggplot(agg_size, aes(x = PC1, y = cal.spl)) +
geom_jitter(position = position_jitter(width = 0.2, height = 0.2), aes(size = count), color = viridis(10)[1]) +
labs(x = "Body size (PC1)", y = "Sound pressure level (dB)", color = "Period", size = "Sample\n size") +
# scale_color_viridis_d(begin = 0.1, end = 0.8, alpha = 0.7) +
theme_classic(base_size = 30)
# geom_abline(slope = c(ES_continious = sm_size[2, 1], ES_continious_plus_ES_interaction=  sm_size[2, 1] + sm_size[4, 1]), intercept = c(intercept = sm_size[1, 1], intercept_plus_ES_categorical = sm_size[1, 1] + sm_size[3, 1]), color = viridis(2, begin = 0.2, end = 0.8, alpha = 0.6)[2:1], size = 1) +
# guides(colour = guide_legend(override.aes = list(size=8)))
ggsave("./output/body_size_vs_SPL.jpeg", width = 11, height = 7)
ggplot(agg_size, aes(x = lift.weight, y = cal.spl)) +
geom_jitter(position = position_jitter(width = 0.2, height = 0.2), aes(size = count), color = viridis(10)[1]) +
labs(x = "Lifiting power (g)", y = "Sound pressure level (dB)", color = "Period", size = "Sample\n size") +
# scale_color_viridis_d(begin = 0.1, end = 0.8, alpha = 0.7) +
theme_classic(base_size = 30)
# geom_abline(slope = c(ES_continious = sm_size[2, 1], ES_continious_plus_ES_interaction=  sm_size[2, 1] + sm_size[4, 1]), intercept = c(intercept = sm_size[1, 1], intercept_plus_ES_categorical = sm_size[1, 1] + sm_size[3, 1]), color = viridis(2, begin = 0.2, end = 0.8, alpha = 0.6)[2:1], size = 1) +
# guides(colour = guide_legend(override.aes = list(size=8)))
ggsave("./output/lifting_power_vs_SPL.jpeg", width = 11, height = 7)
# Chunk 19: Effect size posterior distribution condition
# simplify names
colnames(best_mod_size$Sol) <- c("Intercept", "lifted weight","Body size (PC1)")
# stack posteriors
Y <- stack(as.data.frame(best_mod_size$Sol[, -1]))
# plot posteriors
ggplot(Y, aes(y=values, x = ind)) +
geom_hline(yintercept = 0, col = "red", lty = 2) +
geom_violin(color = "gray40", fill = viridis(n = 1, alpha = 0.25, begin = 0.4)) +
labs(y = "Effect size posterior distribution", x = "Predictor") +
theme_classic(base_size = 24) +
theme(axis.text.x = element_text(angle = 45,  vjust = 1, hjust=1))
# Chunk 20: SPL vs playback models
playback_dat <- rm_outlier_amp[rm_outlier_amp$Treatment %in% c("Before_playback", "After_playback"), ]
# label 2019 recordings
playback_dat$ID <- ifelse(grepl("2019", playback_dat$org.sound.file), paste(playback_dat$ID, "(2019)"), playback_dat$ID)
# remove indiviudal recorded in 2019 and 2021
playback_dat <- playback_dat[playback_dat$ID != "397 (2019)", ]
random_slope_mod <- lmer(cal.spl ~ Treatment  + (Treatment|ID), data = playback_dat, REML = FALSE)
interaction_size_mod <- lmer(cal.spl ~ PC1 + Treatment + PC1:Treatment + (1|ID), data = playback_dat, REML = FALSE)
interaction_lift_mod <- lmer(cal.spl ~ PC1 + lift.weight + PC1:lift.weight + (1|ID), data = playback_dat, REML = FALSE)
random_intercept_only_mod <- lmer(cal.spl ~ Treatment  + (1|ID) + (1|songtype), data = playback_dat, REML = FALSE)
null_mod <- lmer(cal.spl ~ 1  + (1|ID) + (1|songtype), data = playback_dat, REML = FALSE)
# Chunk 21: SPL vs playback p values
d1 <- (-2*logLik(random_intercept_only_mod)) + (2*logLik(random_slope_mod))
pval_rand_slope_vs_rand_intercept <- 0.5*pchisq(d1[1], 0, lower.tail=FALSE) + 0.5*pchisq(d1[1], 1, lower.tail=FALSE)
d2 <- (-2*logLik(null_mod)) + (2*logLik(random_intercept_only_mod))
pval_rand_intercept_vs_null <- 0.5*pchisq(d2[1], 0, lower.tail=FALSE) + 0.5*pchisq(d2[1], 1, lower.tail=FALSE)
d3 <- (-2*logLik(null_mod)) + (2*logLik(random_slope_mod))
pval_rand_slope_vs_null <- 0.5*pchisq(d3[1], 0, lower.tail=FALSE) + 0.5*pchisq(d3[1], 1, lower.tail=FALSE)
d4 <- (-2*logLik(interaction_size_mod)) + (2*logLik(random_slope_mod))
pval_rand_slope_vs_interaction_size <- 0.5*pchisq(d4[1], 0, lower.tail=FALSE) + 0.5*pchisq(d4[1], 1, lower.tail=FALSE)
d5 <- (-2*logLik(interaction_lift_mod)) + (2*logLik(random_slope_mod))
pval_rand_slope_vs_interaction_lift <- 0.5*pchisq(d5[1], 0, lower.tail=FALSE) + 0.5*pchisq(d5[1], 1, lower.tail=FALSE)
# Chunk 22: SPL vs playback plot
agg_playback <- aggregate(cal.spl ~ Treatment + ID, data = playback_dat, mean)
agg_playback$sd <- aggregate(cal.spl ~ Treatment + ID, data = playback_dat, sd)$cal.spl
agg_playback$Treatment <- factor(gsub("_playback", "", agg_playback$Treatment), levels = c("Before", "After"))
ggplot(agg_playback, aes(x = Treatment, y = cal.spl, color = Treatment)) +
geom_point(size = 2, show.legend = FALSE) +
geom_errorbar(width=.05, aes(ymin = cal.spl - sd, ymax = cal.spl + sd), show.legend = FALSE) +
labs(x = "Playback treatment", y = "Sound pressure level (dB)", color = "Period") +
scale_color_viridis_d(begin = 0.1, end = 0.8, alpha = 1) +
facet_wrap(~ ID, nrow = 3, scales = "free_y") +
theme_classic(base_size = 24)
sub_agg <- agg_playback[agg_playback$ID %in% unique(agg_playback$ID)[1:8],]
sub_agg$ID <- substr(sub_agg$ID, 0, 3)
ggplot(sub_agg, aes(x = Treatment, y = cal.spl, color = Treatment)) +
geom_point(size = 4) +
geom_errorbar(width=.3, aes(ymin = cal.spl - sd, ymax = cal.spl + sd), show.legend = FALSE, lwd = 2) +
labs(x = "Playback treatment", y = "Sound pressure level (dB)", color = "Period") +
scale_color_viridis_d(begin = 0.1, end = 0.8, alpha = 1) +
facet_wrap(~ ID, nrow = 2, scales = "free_y") +
theme_classic(base_size = 30) +
theme(axis.text.x = element_blank())
ggsave("./output/SPL_by_playback.jpeg", width = 14, height = 7)
# Chunk 23: SPL vs coordination models
# fixed effects with HPD intervals
coord_data <- rm_outlier_amp[rm_outlier_amp$org.sound.file %in% rm_outlier_amp$org.sound.file[rm_outlier_amp$Treatment == "Coordination"], ]
coord_data <- coord_data[coord_data$Treatment %in%  c("Regular_singing","Coordination"), ]
random_slope_mod <- lmer(cal.spl ~ Treatment  + (Treatment|ID), data = coord_data, REML = FALSE)
random_intercept_only_mod <- lmer(cal.spl ~ Treatment + (1|ID), data = coord_data, REML = FALSE)
null_mod <- lmer(cal.spl ~ 1  + (1|ID), data = coord_data, REML = FALSE)
# Chunk 24: SPL vs coordination p values
d1 <- (-2*logLik(random_intercept_only_mod)) + (2*logLik(random_slope_mod))
random_slope_vs_random_intercept <- 0.5*pchisq(d1[1], 0, lower.tail=FALSE) + 0.5*pchisq(d1[1], 1, lower.tail=FALSE)
d2 <- (-2*logLik(null_mod)) + (2*logLik(random_intercept_only_mod))
random_intercept_vs_null <- 0.5*pchisq(d2[1], 0, lower.tail=FALSE) + 0.5*pchisq(d2[1], 1, lower.tail=FALSE)
d3 <- (-2*logLik(null_mod)) + (2*logLik(random_slope_mod))
random_slope_vs_null <- 0.5*pchisq(d3[1], 0, lower.tail=FALSE) + 0.5*pchisq(d3[1], 1, lower.tail=FALSE)
agg_coord <- aggregate(cal.spl ~ Treatment + ID, data = coord_data, mean)
agg_coord$sd <- aggregate(cal.spl ~ Treatment + ID, data = coord_data, sd)$cal.spl
agg_coord$Treatment <- factor(ifelse(agg_coord$Treatment == "Coordination", "Coordinated", "Solo"), levels = c("Solo", "Coordinated"))
ggplot(agg_coord, aes(x = Treatment, y = cal.spl, color = Treatment)) +
geom_point(size = 2, show.legend = FALSE) +
geom_errorbar(width=.05, aes(ymin = cal.spl - sd, ymax = cal.spl + sd), show.legend = FALSE) +
labs(x = "coord treatment", y = "Sound pressure level (dB)", color = "Period") +
scale_color_viridis_d(begin = 0.1, end = 0.8, alpha = 1) +
facet_wrap(~ ID, nrow = 2, scales = "free_y") +
theme_classic(base_size = 24)
sub_agg <- agg_coord[agg_coord$ID %in% unique(agg_coord$ID)[c(1:4, 11:)],]
sub_agg$ID <- substr(sub_agg$ID, 0, 3)
ggplot(sub_agg, aes(x = Treatment, y = cal.spl, color = Treatment)) +
geom_point(size = 4, show.legend = TRUE) +
geom_errorbar(width=.3, aes(ymin = cal.spl - sd, ymax = cal.spl + sd), show.legend = FALSE, lwd = 2) +
labs(x = "Singing type", y = "Sound pressure level (dB)", color = "Singing type") +
scale_color_viridis_d(begin = 0.1, end = 0.8, alpha = 1) +
facet_wrap(~ ID, nrow = 2, scales = "free_y") +
theme_classic(base_size = 30)  +
theme(axis.text.x = element_blank())
ggsave("./output/SPL_by_coordination.jpeg", width = 14, height = 7)
sub_agg <- agg_coord[agg_coord$ID %in% unique(agg_coord$ID)[c(1:4, 11:)],]
sub_agg <- agg_coord[agg_coord$ID %in% unique(agg_coord$ID)[c(1:4, 11:9)],]
sub_agg$ID <- substr(sub_agg$ID, 0, 3)
ggplot(sub_agg, aes(x = Treatment, y = cal.spl, color = Treatment)) +
geom_point(size = 4, show.legend = TRUE) +
geom_errorbar(width=.3, aes(ymin = cal.spl - sd, ymax = cal.spl + sd), show.legend = FALSE, lwd = 2) +
labs(x = "Singing type", y = "Sound pressure level (dB)", color = "Singing type") +
scale_color_viridis_d(begin = 0.1, end = 0.8, alpha = 1) +
facet_wrap(~ ID, nrow = 2, scales = "free_y") +
theme_classic(base_size = 30)  +
theme(axis.text.x = element_blank())
sub_agg <- agg_coord[agg_coord$ID %in% unique(agg_coord$ID)[c(1:4, 11:8)],]
sub_agg$ID <- substr(sub_agg$ID, 0, 3)
ggplot(sub_agg, aes(x = Treatment, y = cal.spl, color = Treatment)) +
geom_point(size = 4, show.legend = TRUE) +
geom_errorbar(width=.3, aes(ymin = cal.spl - sd, ymax = cal.spl + sd), show.legend = FALSE, lwd = 2) +
labs(x = "Singing type", y = "Sound pressure level (dB)", color = "Singing type") +
scale_color_viridis_d(begin = 0.1, end = 0.8, alpha = 1) +
facet_wrap(~ ID, nrow = 2, scales = "free_y") +
theme_classic(base_size = 30)  +
theme(axis.text.x = element_blank())
ggsave("./output/SPL_by_coordination.jpeg", width = 14, height = 7)
# Chunk 1: Load packages
## vector with package names
x <- c( "pbapply", "parallel", "ggplot2", "warbleR", "Rraven", "viridis", "readxl", "rptR", "MCMCglmm", "MuMIn", "corrplot", "lme4", "grid", "gridExtra", "dynaSpec")
aa <- lapply(x, function(y) {
# check if installed, if not then install
if (!y %in% installed.packages()[,"Package"])
install.packages(y)
# load package
try(require(y, character.only = T), silent = T)
})
# Chunk 2: functions and parameters
#functions and parameters
knitr::opts_knit$set(root.dir = normalizePath(".."))
knitr::opts_chunk$set(dpi = 50, fig.width = 12, warning = FALSE, message = FALSE)
# ggplot2 theme
# theme_set(theme_classic(base_size = 20))
cut_path <- "./data/raw/cuts"
treatments <- c("Calibration", "Regular_singing", "Coordination", "After_chase",
"Before_playback", "After_playback", "Before_interaction", "After_interaction", "Before_noise", "After_noise")
# iterations for MCMCglmm models
itrns <- 100000
# functions from https://rdrr.io/rforge/rptR/src/R/rpt.mcmcLMM.R
rpt.mcmcLMM <- function(y, groups, CI=0.95, prior=NULL, verbose=FALSE, ...){
# initial checks
if(length(y)!= length(groups)) stop("y and group are of unequal length")
# preparation
groups <- factor(groups)
if(is.null(prior)) prior <- list(R=list(V=1,n=10e-2), G=list(G1=list(V=1,n=10e-2)) )
# point estimation according to model 8 and equation 9
mod   <- MCMCglmm(y ~ 1, random=~groups, family="gaussian", data=data.frame(y=y,groups=groups), prior=prior, verbose=verbose, ...)
var.a <- mod$VCV[,"groups"]
var.e <- mod$VCV[,"units"]
postR <- var.a / (var.a + var.e)
# point estimate
R     <- posterior.mode( postR )
# credibility interval estimation from paterior distribution
CI.R    <- coda::HPDinterval(postR,CI)[1,]
se 	    <- sd(postR)
# 'significance test'
P 	  <- NA
res = list(call=match.call(), datatype="Gaussian", method="LMM.MCMC", CI=CI,
R=R, CI.R=CI.R, se=se, P=P)
# class(res) <- "rpt"
return(res)
}
## print Gelman-Rubin convergence statistics, plots traces and autocorrelations
mcmc_diagnostics <- function(rep_mods_list){
for(w in 1:length(rep_mods_list))
{
mod_name <- names(rep_mods_list)[w]
if(mod_name == "1") mod_name <- "Null"
print(paste("model:", mod_name))
Y <- lapply(rep_mods_list[[w]], "[[", "Sol")
## add global plots and gelman test
# gelman_diagnostic
gel_diag <- as.data.frame(gelman.diag(mcmc.list(Y))$psrf)
# add estimate as column
gel_diag$estimate <- rownames(gel_diag)
# reorder columns
gel_diag <- gel_diag[, c(3, 1, 2)]
par(mfrow = c(1, 1))
# plot table
grid.newpage()
grid.draw(tableGrob(gel_diag, rows = NULL, theme=ttheme_default(base_size = 25)))
par(mfrow = c(1, 4))
traceplot(Y, col = adjustcolor(c("yellow","blue", "red"), alpha.f = 0.6))
autocorr.plot(x = Y[[1]], auto.layout = FALSE, lwd =4, col = "red")
}
}
# Chunk 3: read data
amp <- read.csv("./output/calibrated_amplitude_all_songs.csv")
amp$Treatment[amp$Treatment == "Regular_sining"] <- "Regular_singing"
# Chunk 5: repeatability plot
repts_df <- read.csv("./output/repeatability_optimization.csv")
pd <- position_dodge(width = 0.1)
ggplot(data = repts_df, aes(x = 1 - max_quantile, y = repeatability, color = only.low.outliers, group = only.low.outliers)) +
geom_hline(yintercept = 0.5, col = adjustcolor("red", alpha.f = 0.5)) +
geom_point(size = 2, position = pd) +
geom_errorbar(width=.05, aes(ymin = lowCI, ymax = hiCI), position = pd) +
scale_color_viridis(discrete = TRUE, begin = 0.2, end = 0.8, alpha = 0.7) +
geom_line(position = pd) +
labs(y = "Repeatability",  x = "Upper quantile used") +
ylim(c(0, 1)) + xlim(c(1, 0)) +
facet_wrap(~ outliers, scales = "fixed") +
theme_classic(base_size = 24)
repts_df$range <- repts_df$hiCI - repts_df$lowCI
# repts_df[order(repts_df$repeatability), c("max_quantile", "outliers", "only.low.outliers", "repeatability", "range")]
repts_df <- repts_df[order(repts_df$repeatability, decreasing = TRUE), ]
kable(head(repts_df))
# Chunk 6: repetability plot for presentation
# keep only morning recs, only regular singing and only from 2021
amp_morn <- amp[amp$period == "morning" & amp$year == 2021 & amp$Treatment == "Regular_singing", ]
# keep only males recorded at least twice
# count_sf <- table(amp_morn$ID[!duplicated(amp_morn$org.sound.file)])
amp_morn_rep <- amp_morn[amp_morn$ID %in% names(count_sf)[count_sf > 1], ]
amp_morn_rep <- amp_morn
quant_subet <- lapply(unique(amp_morn_rep$org.sound.file), function(y){
X <- amp_morn_rep[amp_morn_rep$org.sound.file == y, ]
# remove outliers
outlier_quant <- quantile(X$cal.spl, c(0.1, 1- 0.1))
X <- X[X$cal.spl >= outlier_quant[1],]
# quantlie for each max quantile
quant <- quantile(X$cal.spl, probs = 1 - 0.4)
# subset
X <- X[X$cal.spl >= quant, ]
})
quant_subet <- do.call(rbind, quant_subet)
ggplot(quant_subet, aes(x = factor(ID), y = cal.spl, width = 2)) +
geom_violin(fill = viridis(10)[8])+
theme_classic(base_size = 30) +
labs(x = "Individual", y = "Sound pressure level (dB)") +
theme(axis.text.x = element_text(angle = 90))
ggsave("./output/individual_differences_in_spl.jpeg", width = 14, height = 7)
# Chunk 7: apply subseting based on repeatability
# compose variable to remove low values and outliers based on repeatabiliy
amp$osf.treat <- paste(amp$org.sound.file, amp$Treatment, sep = "-")
rm_outlier_amp_l <- lapply(unique(amp$osf.treat), function(y){
X <- amp[amp$osf.treat == y, ]
# remove outliers
outlier_quant <- quantile(X$cal.spl, c(repts_df$outliers[1], 1))
X <- X[X$cal.spl >= outlier_quant[1] & X$cal.spl <= outlier_quant[2],]
# quantlie for each max quantile (0.6 was selected due to high repeatability)
quant <- quantile(X$cal.spl, probs = repts_df$max_quantile[1])
# subset
X <- X[X$cal.spl >= quant, ]
})
rm_outlier_amp <- do.call(rbind, rm_outlier_amp_l)
attach(readRDS("./output/mcmcglmm_period_models.RDS"))
mod_list <- lapply(period_mods, "[[", 1)
names(mod_list) <- gsub("cal.spl ~ ", "", period_formulas)
model_selection <- model.sel(mod_list, rank="DIC")
model_selection
# fixed effects with HPD intervals
best_mod_period <- period_mods[[which(names(period_mods) == row.names(model_selection)[1])]][[1]]
sm <- as.data.frame(summary(best_mod_period)$solutions[, -5])
sm
as.data.frame(summary(best_mod_period)$solutions
)
