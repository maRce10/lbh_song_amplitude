# point estimation according to model 8 and equation 9
mod   <- MCMCglmm(y ~ 1, random=~groups, family="gaussian", data=data.frame(y=y,groups=groups), prior=prior, verbose=verbose, ...)
var.a <- mod$VCV[,"groups"]
var.e <- mod$VCV[,"units"]
postR <- var.a / (var.a + var.e)
# point estimate
R     <- posterior.mode( postR )
# credibility interval estimation from paterior distribution
CI.R    <- coda::HPDinterval(postR,CI)[1,]
se 	    <- sd(postR)
# 'significance test'
P 	  <- NA
res = list(call=match.call(), datatype="Gaussian", method="LMM.MCMC", CI=CI,
R=R, CI.R=CI.R, se=se, P=P)
# class(res) <- "rpt"
return(res)
}
## print Gelman-Rubin convergence statistics, plots traces and autocorrelations
mcmc_diagnostics <- function(rep_mods_list){
for(w in 1:length(rep_mods_list))
{
mod_name <- names(rep_mods_list)[w]
if(mod_name == "1") mod_name <- "Null"
print(paste("model:", mod_name))
Y <- lapply(rep_mods_list[[w]], "[[", "Sol")
## add global plots and gelman test
# gelman_diagnostic
gel_diag <- as.data.frame(gelman.diag(mcmc.list(Y))$psrf)
# add estimate as column
gel_diag$estimate <- rownames(gel_diag)
# reorder columns
gel_diag <- gel_diag[, c(3, 1, 2)]
par(mfrow = c(1, 1))
# plot table
grid.newpage()
grid.draw(tableGrob(gel_diag, rows = NULL, theme=ttheme_default(base_size = 25)))
par(mfrow = c(1, 4))
traceplot(Y, col = adjustcolor(c("yellow","blue", "red"), alpha.f = 0.6))
autocorr.plot(x = Y[[1]], auto.layout = FALSE, lwd =4, col = "red")
}
}
amp <- read.csv("./output/calibrated_amplitude_all_songs.csv")
amp$Treatment[amp$Treatment == "Regular_sining"] <- "Regular_singing"
# subset data
dat_chase <- rm_outlier_amp[rm_outlier_amp$org.sound.file %in% rm_outlier_amp$org.sound.file[rm_outlier_amp$Treatment == "After_chase"], ]
# compose variable to remove low values and outliers based on repeatabiliy
amp$osf.treat <- paste(amp$org.sound.file, amp$Treatment, sep = "-")
rm_outlier_amp_l <- lapply(unique(amp$osf.treat), function(y){
X <- amp[amp$osf.treat == y, ]
# remove outliers
outlier_quant <- quantile(X$cal.spl, c(repts_df$outliers[1], 1))
X <- X[X$cal.spl >= outlier_quant[1] & X$cal.spl <= outlier_quant[2],]
# quantlie for each max quantile (0.6 was selected due to high repeatability)
quant <- quantile(X$cal.spl, probs = repts_df$max_quantile[1])
# subset
X <- X[X$cal.spl >= quant, ]
})
rm_outlier_amp <- do.call(rbind, rm_outlier_amp_l)
repts_df <- read.csv("./output/repeatability_optimization.csv")
pd <- position_dodge(width = 0.1)
ggplot(data = repts_df, aes(x = 1 - max_quantile, y = repeatability, color = only.low.outliers, group = only.low.outliers)) +
geom_hline(yintercept = 0.5, col = adjustcolor("red", alpha.f = 0.5)) +
geom_point(size = 2, position = pd) +
geom_errorbar(width=.05, aes(ymin = lowCI, ymax = hiCI), position = pd) +
scale_color_viridis(discrete = TRUE, begin = 0.2, end = 0.8, alpha = 0.7) +
geom_line(position = pd) +
labs(y = "Repeatability",  x = "Upper quantile used") +
ylim(c(0, 1)) + xlim(c(1, 0)) +
facet_wrap(~ outliers, scales = "fixed") +
theme_classic(base_size = 24)
repts_df$range <- repts_df$hiCI - repts_df$lowCI
# repts_df[order(repts_df$repeatability), c("max_quantile", "outliers", "only.low.outliers", "repeatability", "range")]
repts_df <- repts_df[order(repts_df$repeatability, decreasing = TRUE), ]
kable(head(repts_df))
# compose variable to remove low values and outliers based on repeatabiliy
amp$osf.treat <- paste(amp$org.sound.file, amp$Treatment, sep = "-")
rm_outlier_amp_l <- lapply(unique(amp$osf.treat), function(y){
X <- amp[amp$osf.treat == y, ]
# remove outliers
outlier_quant <- quantile(X$cal.spl, c(repts_df$outliers[1], 1))
X <- X[X$cal.spl >= outlier_quant[1] & X$cal.spl <= outlier_quant[2],]
# quantlie for each max quantile (0.6 was selected due to high repeatability)
quant <- quantile(X$cal.spl, probs = repts_df$max_quantile[1])
# subset
X <- X[X$cal.spl >= quant, ]
})
rm_outlier_amp <- do.call(rbind, rm_outlier_amp_l)
# subset data
dat_chase <- rm_outlier_amp[rm_outlier_amp$org.sound.file %in% rm_outlier_amp$org.sound.file[rm_outlier_amp$Treatment == "After_chase"], ]
dat_chase <- dat_chase[dat_chase$Treatment %in% c("Regular_singing", "After_chase"),]
dat_chase$inter_treatment <- ifelse(grepl("After", dat_chase$Treatment), "2_After", "1_Before")
dat_chase$inter_type <- "2_Chase"
dat_interaction <- rm_outlier_amp[rm_outlier_amp$Treatment %in% c("After_interaction", "Before_interaction"), ]
dat_interaction$inter_treatment <- ifelse(grepl("After", dat_interaction$Treatment), "2_After", "1_Before")
dat_interaction$inter_type <- "1_Perch_interaction"
# fix range of non-calibrated recs
dat_interaction$cal.spl[dat_interaction$year < 2021] <- dat_interaction$cal.spl[dat_interaction$year < 2021] + mean(dat_interaction$cal.spl[dat_interaction$year == 2021]) - mean(dat_interaction$cal.spl[dat_interaction$year < 2021])
dat_aggresive_inter <- rbind(dat_interaction, dat_chase)
# fix low value one
dat_aggresive_inter$cal.spl[dat_aggresive_inter$sound.files == dat_aggresive_inter$sound.files[which.min(dat_aggresive_inter$cal.spl)]] <- dat_aggresive_inter$cal.spl[dat_aggresive_inter$sound.files == dat_aggresive_inter$sound.files[which.min(dat_aggresive_inter$cal.spl)]]  +  mean(dat_aggresive_inter$cal.spl[dat_aggresive_inter$sound.files != dat_aggresive_inter$sound.files[which.min(dat_aggresive_inter$cal.spl)]]) - mean(dat_aggresive_inter$cal.spl[dat_aggresive_inter$sound.files == dat_aggresive_inter$sound.files[which.min(dat_aggresive_inter$cal.spl)]])
attach(readRDS("./output/mcmcglmm_interaction_models.RDS"))
mod_list <- lapply(inter_mods, "[[", 1)
names(mod_list) <- gsub("cal.spl ~ ", "", interaction_formulas)
model_selection <- model.sel(mod_list, rank="DIC")
model_selection
View(dat_aggresive_inter)
unique(dat_aggresive_inter$sound.files)
# model SPL by interaction
interaction_formulas <- c("cal.spl ~ 1", "cal.spl ~ inter_treatment", "cal.spl ~ inter_treatment + inter_type", "cal.spl ~ inter_treatment * inter_type")
# remove video data
dat_aggresive_inter <- dat_aggresive_inter[grep("2013|2014", dat_aggresive_inter$sound.files, invert = TRUE),]
# dat_aggresive_inter$inter_treatment <- factor(dat_aggresive_inter$inter_treatment, levels = c("After", "Before"))
# dat_aggresive_inter$inter_type <- factor(dat_aggresive_inter$inter_type, levels = c("Perch interaction", "Chase"))
inter_mods <- pblapply(interaction_formulas, function(x){
replicate(n = 3, MCMCglmm(as.formula(x), random = ~ ID, data = dat_aggresive_inter, verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE)), simplify = FALSE)
})
names(inter_mods) <- gsub("cal.spl ~ ", "", interaction_formulas)
saveRDS(list(interaction_formulas = interaction_formulas, inter_mods = inter_mods), "./output/mcmcglmm_interaction_models_2.RDS")
attach(readRDS("./output/mcmcglmm_interaction_models_2.RDS"))
mod_list <- lapply(inter_mods, "[[", 1)
names(mod_list) <- gsub("cal.spl ~ ", "", interaction_formulas)
model_selection <- model.sel(mod_list, rank="DIC")
model_selection
# fixed effects with HPD intervals
best_mod_interaction <- inter_mods[[which(names(inter_mods) == row.names(model_selection)[1])]][[1]]
sm_interaction <- as.data.frame(summary(best_mod_interaction)$solutions[, -5])
sm_interaction
# subset data
# dat_aggresive_inter$inter_treatment <- factor(dat_aggresive_inter$inter_treatment, levels = c("1_Before", "2_After"))
dat_aggresive_inter$year <- factor(dat_aggresive_inter$year, levels = c("2013", "2014", "2019", "2021"))
# dat_aggresive_inter$inter_type <- gsub("_", " ", dat_aggresive_inter$inter_type)
# dat_aggresive_inter$inter_type <- factor(dat_aggresive_inter$inter_type, levels = c("1_Perch_interaction", "2_Chase"))
agg_aggresive_inter <- aggregate(cal.spl ~ ID + inter_type + inter_treatment + year, data = dat_aggresive_inter, mean)
agg_aggresive_inter$ID <- as.character(agg_aggresive_inter$ID)
ggplot(dat_aggresive_inter, aes(x = inter_treatment, y = cal.spl)) +
geom_violin(color = "gray40", fill = viridis(n = 1, alpha = 0.25, begin = 0.4)) +
geom_point(size = 4, data = agg_aggresive_inter, aes(group = ID, color = year)) +
geom_line(data = agg_aggresive_inter, aes(group = ID, color = year)) +
labs(x = "Context", y = "Sound pressure level (dB)") +
facet_wrap(~ inter_type) +
scale_color_viridis_d(begin = 0.1, end = 0.8, alpha = 0.7) +
theme_classic(base_size = 24)
# extract mcmcs
mcmcs <- best_mod_interaction$Sol
# make empty list
mcmc_l <- list()
##  perch interaction before playback
mcmc_l[[length(mcmc_l) + 1]] <- data.frame(spl = mcmcs[,"(Intercept)"], treatment = "Before", type = "Perch interaction")
##  perch interaction after playback
mcmc_l[[length(mcmc_l) + 1]] <- data.frame(spl = mcmcs[,"(Intercept)"] + mcmcs[,"inter_treatment2_After"], treatment = "After", type = "Perch interaction"
)
# chase before playback
mcmc_l[[length(mcmc_l) + 1]] <- data.frame(spl =  mcmcs[,"(Intercept)"] +
mcmcs[,"inter_type2_Chase"], treatment = "Before", type = "Chase"
)
# chase after playback
mcmc_l[[length(mcmc_l) + 1]] <- data.frame(spl = mcmcs[,"(Intercept)"] +
mcmcs[,"inter_type2_Chase"] +
mcmcs[, "inter_treatment2_After:inter_type2_Chase"], treatment = "After", type = "Chase")
mcmc_df <- do.call(rbind, mcmc_l)
colnames(mcmc_df)[1] <- "spl"
mcmc_df$treatment_type <- paste(mcmc_df$treatment, mcmc_df$type, sep = "-")
# p-values
combs <- combn(x = unique(mcmc_df$treatment_type), m = 2)[, c(1, 6)]
pvals_l <- lapply(1:ncol(combs), function(x){
mcmc1 <- mcmc_df$spl[mcmc_df$treatment_type == combs[1, x]]
mcmc2 <- mcmc_df$spl[mcmc_df$treatment_type == combs[2, x]]
p <- if (mean(mcmc2) > mean(mcmc1))
sum(mcmc1  > mcmc2) / length(mcmc1) else
sum(mcmc2  > mcmc1) / length(mcmc1)
out <- data.frame(mcmc1 =  combs[1, x], mcmc2 = combs[2, x], p = p)
return(out)
})
pvals <- do.call(rbind, pvals_l)
mcmc_df$treatment <-factor(mcmc_df$treatment, levels = c("Before", "After"))
mcmc_df$type <-factor(mcmc_df$type, levels = c("Perch interaction", "Chase"))
# plot posteriors
ggplot(mcmc_df, aes(y=spl, x = treatment)) +
# geom_hline(yintercept = 0, col = "red", lty = 2) +
geom_violin(color = "gray40", fill = viridis(n = 1, alpha = 0.25, begin = 0.4)) +
labs(y = "SPL posterior distribution",x = "Predictor") +
theme_classic(base_size = 24) +
facet_wrap(~ type) +
theme(axis.text.x = element_text(angle = 45,  vjust = 0.9, hjust=1))
kable(pvals)
sm_interaction
best_mod_interaction
summary(best_mod_interaction)
head(mcmc_df)
aggregate(spl ~ treatment_type, mcmc_df, mean)
aggregate(spl ~ type + treatment, mcmc_df, mean)
agg <- aggregate(spl ~ type + treatment, mcmc_df, mean)
# plot posteriors
ggplot(mcmc_df, aes(y=spl, x = treatment)) +
geom_point(data = agg) +
# geom_hline(yintercept = 0, col = "red", lty = 2) +
geom_violin(color = "gray40", fill = viridis(n = 1, alpha = 0.25, begin = 0.4)) +
labs(y = "SPL posterior distribution",x = "Predictor") +
theme_classic(base_size = 24) +
facet_wrap(~ type) +
theme(axis.text.x = element_text(angle = 45,  vjust = 0.9, hjust=1))
# plot posteriors
ggplot(mcmc_df, aes(y=spl, x = treatment)) +
geom_point(data = agg) +
geom_hline(data = agg) +
geom_violin(color = "gray40", fill = viridis(n = 1, alpha = 0.25, begin = 0.4)) +
labs(y = "SPL posterior distribution",x = "Predictor") +
theme_classic(base_size = 24) +
facet_wrap(~ type) +
theme(axis.text.x = element_text(angle = 45,  vjust = 0.9, hjust=1))
# plot posteriors
ggplot(mcmc_df, aes(y=spl, x = treatment)) +
geom_point(data = agg) +
geom_line(data = agg) +
geom_violin(color = "gray40", fill = viridis(n = 1, alpha = 0.25, begin = 0.4)) +
labs(y = "SPL posterior distribution",x = "Predictor") +
theme_classic(base_size = 24) +
facet_wrap(~ type) +
theme(axis.text.x = element_text(angle = 45,  vjust = 0.9, hjust=1))
# plot posteriors
ggplot(mcmc_df, aes(y=spl, x = treatment)) +
geom_point(data = agg) +
geom_abline(data = agg) +
geom_violin(color = "gray40", fill = viridis(n = 1, alpha = 0.25, begin = 0.4)) +
labs(y = "SPL posterior distribution",x = "Predictor") +
theme_classic(base_size = 24) +
facet_wrap(~ type) +
theme(axis.text.x = element_text(angle = 45,  vjust = 0.9, hjust=1))
# plot posteriors
ggplot(mcmc_df, aes(y=spl, x = treatment)) +
geom_point(data = agg) +
geom_line(data = agg, stat = "identity") +
geom_violin(color = "gray40", fill = viridis(n = 1, alpha = 0.25, begin = 0.4)) +
labs(y = "SPL posterior distribution",x = "Predictor") +
theme_classic(base_size = 24) +
facet_wrap(~ type) +
theme(axis.text.x = element_text(angle = 45,  vjust = 0.9, hjust=1))
attach(readRDS("./output/mcmcglmm_interaction_models.RDS"))
mod_list <- lapply(inter_mods, "[[", 1)
names(mod_list) <- gsub("cal.spl ~ ", "", interaction_formulas)
model_selection <- model.sel(mod_list, rank="DIC")
model_selection
# fixed effects with HPD intervals
best_mod_interaction <- inter_mods[[which(names(inter_mods) == row.names(model_selection)[1])]][[1]]
sm_interaction <- as.data.frame(summary(best_mod_interaction)$solutions[, -5])
sm_interaction
summary(best_mod_interaction)$solutions
# subset data
# dat_aggresive_inter$inter_treatment <- factor(dat_aggresive_inter$inter_treatment, levels = c("1_Before", "2_After"))
dat_aggresive_inter$year <- factor(dat_aggresive_inter$year, levels = c("2013", "2014", "2019", "2021"))
# dat_aggresive_inter$inter_type <- gsub("_", " ", dat_aggresive_inter$inter_type)
# dat_aggresive_inter$inter_type <- factor(dat_aggresive_inter$inter_type, levels = c("1_Perch_interaction", "2_Chase"))
agg_aggresive_inter <- aggregate(cal.spl ~ ID + inter_type + inter_treatment + year, data = dat_aggresive_inter, mean)
agg_aggresive_inter$ID <- as.character(agg_aggresive_inter$ID)
ggplot(dat_aggresive_inter, aes(x = inter_treatment, y = cal.spl)) +
geom_violin(color = "gray40", fill = viridis(n = 1, alpha = 0.25, begin = 0.4)) +
geom_point(size = 4, data = agg_aggresive_inter, aes(group = ID, color = year)) +
geom_line(data = agg_aggresive_inter, aes(group = ID, color = year)) +
labs(x = "Context", y = "Sound pressure level (dB)") +
facet_wrap(~ inter_type) +
scale_color_viridis_d(begin = 0.1, end = 0.8, alpha = 0.7) +
theme_classic(base_size = 24)
# extract mcmcs
mcmcs <- best_mod_interaction$Sol
# make empty list
mcmc_l <- list()
##  perch interaction before playback
mcmc_l[[length(mcmc_l) + 1]] <- data.frame(spl = mcmcs[,"(Intercept)"], treatment = "Before", type = "Perch interaction")
##  perch interaction after playback
mcmc_l[[length(mcmc_l) + 1]] <- data.frame(spl = mcmcs[,"(Intercept)"] + mcmcs[,"inter_treatment2_After"], treatment = "After", type = "Perch interaction"
)
# chase before playback
mcmc_l[[length(mcmc_l) + 1]] <- data.frame(spl =  mcmcs[,"(Intercept)"] +
mcmcs[,"inter_type2_Chase"], treatment = "Before", type = "Chase"
)
# chase after playback
mcmc_l[[length(mcmc_l) + 1]] <- data.frame(spl = mcmcs[,"(Intercept)"] +
mcmcs[,"inter_type2_Chase"] +
mcmcs[, "inter_treatment2_After:inter_type2_Chase"], treatment = "After", type = "Chase")
mcmc_df <- do.call(rbind, mcmc_l)
colnames(mcmc_df)[1] <- "spl"
mcmc_df$treatment_type <- paste(mcmc_df$treatment, mcmc_df$type, sep = "-")
# p-values
combs <- combn(x = unique(mcmc_df$treatment_type), m = 2)[, c(1, 6)]
pvals_l <- lapply(1:ncol(combs), function(x){
mcmc1 <- mcmc_df$spl[mcmc_df$treatment_type == combs[1, x]]
mcmc2 <- mcmc_df$spl[mcmc_df$treatment_type == combs[2, x]]
p <- if (mean(mcmc2) > mean(mcmc1))
sum(mcmc1  > mcmc2) / length(mcmc1) else
sum(mcmc2  > mcmc1) / length(mcmc1)
out <- data.frame(mcmc1 =  combs[1, x], mcmc2 = combs[2, x], p = p)
return(out)
})
pvals <- do.call(rbind, pvals_l)
mcmc_df$treatment <-factor(mcmc_df$treatment, levels = c("Before", "After"))
mcmc_df$type <-factor(mcmc_df$type, levels = c("Perch interaction", "Chase"))
agg <- aggregate(spl ~ type + treatment, mcmc_df, mean)
# plot posteriors
ggplot(mcmc_df, aes(y=spl, x = treatment)) +
geom_point(data = agg) +
# geom_line(data = agg, stat = "identity") +
geom_violin(color = "gray40", fill = viridis(n = 1, alpha = 0.25, begin = 0.4)) +
labs(y = "SPL posterior distribution",x = "Predictor") +
theme_classic(base_size = 24) +
facet_wrap(~ type) +
theme(axis.text.x = element_text(angle = 45,  vjust = 0.9, hjust=1))
kable(pvals)
agg
# plot posteriors
ggplot(mcmc_df, aes(y=spl, x = treatment)) +
geom_point(data = agg) +
# geom_line(data = agg, stat = "identity") +
geom_violin(color = "gray40", fill = viridis(n = 1, alpha = 0.25, begin = 0.4)) +
labs(y = "SPL posterior distribution",x = "Predictor") +
theme_classic(base_size = 24) +
facet_wrap(~ type) +
theme(axis.text.x = element_text(angle = 45,  vjust = 0.9, hjust=1))
summary(best_mod_interaction)
# model SPL by interaction
interaction_formulas <- c("cal.spl ~ 1", "cal.spl ~ inter_treatment", "cal.spl ~ inter_treatment + inter_type", "cal.spl ~ inter_treatment * inter_type")
# remove video data
dat_aggresive_inter <- dat_aggresive_inter[grep("2013|2014", dat_aggresive_inter$sound.files, invert = TRUE),]
# dat_aggresive_inter$inter_treatment <- factor(dat_aggresive_inter$inter_treatment, levels = c("After", "Before"))
# dat_aggresive_inter$inter_type <- factor(dat_aggresive_inter$inter_type, levels = c("Perch interaction", "Chase"))
inter_mods <- pblapply(interaction_formulas, function(x){
replicate(n = 3, MCMCglmm(as.formula(x), random = ~ ID, data = dat_aggresive_inter, verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE)), simplify = FALSE)
})
names(inter_mods) <- gsub("cal.spl ~ ", "", interaction_formulas)
saveRDS(list(interaction_formulas = interaction_formulas, inter_mods = inter_mods), "./output/mcmcglmm_interaction_models.RDS")
saveRDS(list(interaction_formulas = interaction_formulas, inter_mods = inter_mods), "./output/mcmcglmm_interaction_models.RDS")
veg <- read_excel(path = "./data/raw/Vegetation_density_lbh.xlsx")
head(veg)
veg[, 8:11]
apply(veg[, c("N", "S", "W", "E")], 1, mean)
veg$mean_count <- apply(veg[, c("N", "S", "W", "E")], 1, mean)
veg$mean_count
veg$mean_count <- apply(veg[, c("N", "S", "W", "E")], 1, mean, na.rm = TRUE)
veg$mean_count
hist(veg$mean_count )
# divide by 16 (max number of lines on pole)
veg$mean_count <- veg$mean_count / 16
veg$mean_count
veg$mean_count <- apply(veg[, c("N", "S", "W", "E")], 1, mean, na.rm = TRUE)
# divide by 16 (max number of lines on pole)
veg$mean_count <- 1 - veg$mean_count / 16
veg$mean_count
hist(veg$mean_count)
agg_veg <- aggregate(mean_count ~ ID, veg, mean)
agg_veg
head(agg_veg)
histy(agg_veg)
hist(agg_veg)
hist(agg_veg$mean_count)
veg$mean_count <- apply(veg[, c("N", "S", "W", "E")], 1, mean, na.rm = TRUE)
# divide by 16 (max number of lines on pole)
veg$veg_density <- 1 - veg$mean_count / 16
agg_veg <- aggregate(veg_density ~ ID, veg, mean)
agg_veg
rm_outlier_amp$veg_density <- sapply(1:nrow(rm_outlier_amp), function(x) agg_veg$veg_density[agg_veg$ID == rm_outlier_amp$ID[x]][1])
rm_outlier_amp$veg_density
agg_veg$ID
rm_outlier_amp$ID[x]
x
x = 1
rm_outlier_amp$ID[x]
rm_outlier_amp$veg_density
agg_veg
rm_outlier_amp$ID
unique(rm_outlier_amp$ID)
unique(agg_veg$ID)
intersect(agg_veg$ID,  rm_outlier_amp$ID)
agg_veg$ID
str(agg_veg)
str(rm_outlier_amp)
x = 400
rm_outlier_amp$ID[x]
rm_outlier_amp$ID[460]
rm_outlier_amp$ID[868]
agg_veg$veg_density[agg_veg$ID == rm_outlier_amp$ID[x]]
agg_veg$ID
agg_veg$ID == rm_outlier_amp$ID[x]
agg_veg$ID == as.numeric(rm_outlier_amp$ID[x])
as.numeric(rm_outlier_amp$ID[x])
x = 868
as.numeric(rm_outlier_amp$ID[x])
agg_veg$ID == as.numeric(rm_outlier_amp$ID[x])
rm_outlier_amp$veg_density <- sapply(1:nrow(rm_outlier_amp), function(x) agg_veg$veg_density[agg_veg$ID == as.numeric(rm_outlier_amp$ID[x])])
rm_outlier_amp$veg_density
rm_outlier_amp$veg_density <- sapply(1:nrow(rm_outlier_amp), function(x) agg_veg$veg_density[agg_veg$ID == as.numeric(rm_outlier_amp$ID[x])][1])
rm_outlier_amp$veg_density
unique(rm_outlier_amp$veg_density)
hist(rm_outlier_amp$veg_density)
rm_outlier_amp$veg_density
rm_outlier_amp$veg_density
names(rm_outlier_amp)
caps <- read_excel("/home/m/Dropbox/LBH data/Additional data files/LBH captures data.xlsx")
# same variables as in paper on spatial memory and body size
size_vars <- caps[caps$`Bird ID` %in% amp$ID, c("Bird ID", "Total culmen", "Flattened wing length", "Weight", "Central rectriz")]
# replace 419 central rectriz with mean
size_vars$`Central rectriz`[size_vars$`Bird ID` == 419] <- mean(size_vars$`Central rectriz`, na.rm = TRUE)
cor(size_vars[, c("Total culmen", "Flattened wing length", "Weight", "Central rectriz")], use = "pairwise.complete.obs")
caps <- read_excel("~/data/raw/LBH captures data.xlsx")
caps <- read_excel("./data/raw/LBH captures data.xlsx")
caps <- read_excel("./data/raw/LBH captures data.xlsx")
# same variables as in paper on spatial memory and body size
size_vars <- caps[caps$`Bird ID` %in% amp$ID, c("Bird ID", "Total culmen", "Flattened wing length", "Weight", "Central rectriz")]
# replace 419 central rectriz with mean
size_vars$`Central rectriz`[size_vars$`Bird ID` == 419] <- mean(size_vars$`Central rectriz`, na.rm = TRUE)
cor(size_vars[, c("Total culmen", "Flattened wing length", "Weight", "Central rectriz")], use = "pairwise.complete.obs")
mean_size <- aggregate(. ~ `Bird ID`, data = size_vars, FUN = mean, na.action = "na.omit")
pca <- prcomp(mean_size[, c("Total culmen", "Flattened wing length", "Weight", "Central rectriz")], scale. = TRUE)
summary(pca)
mean_size$PC1 <- pca$x[, 1]
rm_outlier_amp$PC1 <- sapply(1:nrow(rm_outlier_amp), function(x) mean_size$PC1[mean_size$`Bird ID` == rm_outlier_amp$ID[x]][1])
rm_outlier_amp$weight <- sapply(1:nrow(rm_outlier_amp), function(x) mean_size$Weight[mean_size$`Bird ID` == rm_outlier_amp$ID[x]][1])
mean_size <- aggregate(. ~ `Bird ID`, data = size_vars, FUN = mean, na.action = "na.omit")
pca <- prcomp(mean_size[, c("Total culmen", "Flattened wing length", "Weight", "Central rectriz")], scale. = TRUE)
summary(pca)
mean_size$PC1 <- pca$x[, 1]
rm_outlier_amp$PC1 <- sapply(1:nrow(rm_outlier_amp), function(x) mean_size$PC1[mean_size$`Bird ID` == rm_outlier_amp$ID[x]][1])
rm_outlier_amp$weight <- sapply(1:nrow(rm_outlier_amp), function(x) mean_size$Weight[mean_size$`Bird ID` == rm_outlier_amp$ID[x]][1])
### add weight lifted
lift <- read_excel("/home/m/Dropbox/LBH data/Morphology-condition/other files/Uplift power experiment.xlsx", sheet = "Results")
rm_outlier_amp$lift.weight <- sapply(1:nrow(rm_outlier_amp), function(x){
if(rm_outlier_amp$ID[x] == 0) weight <- NA else {
if (rm_outlier_amp$year[x] == 2019)
sub_lift <- lift[grep("\\.2019\\.", lift$Video), ] else
sub_lift <- lift[grep("\\.2021\\.", lift$Video), ]
weights <- sub_lift$Weight[sub_lift$ID == rm_outlier_amp$ID[x]]
if (length(weights) > 0)
# get the mean of the 2 highest flights
weight <- mean(sort(weights, decreasing = TRUE)[1:2]) else
weight <- NA
}
return(weight)
})
### add weight lifted
lift <- read_excel("./data/raw/other files/Uplift power experiment.xlsx", sheet = "Results")
### add weight lifted
lift <- read_excel("./data/raw/Uplift power experiment.xlsx", sheet = "Results")
mean_size <- aggregate(. ~ `Bird ID`, data = size_vars, FUN = mean, na.action = "na.omit")
pca <- prcomp(mean_size[, c("Total culmen", "Flattened wing length", "Weight", "Central rectriz")], scale. = TRUE)
summary(pca)
mean_size$PC1 <- pca$x[, 1]
rm_outlier_amp$PC1 <- sapply(1:nrow(rm_outlier_amp), function(x) mean_size$PC1[mean_size$`Bird ID` == rm_outlier_amp$ID[x]][1])
rm_outlier_amp$weight <- sapply(1:nrow(rm_outlier_amp), function(x) mean_size$Weight[mean_size$`Bird ID` == rm_outlier_amp$ID[x]][1])
### add weight lifted
lift <- read_excel("./data/raw/Uplift power experiment.xlsx", sheet = "Results")
rm_outlier_amp$lift.weight <- sapply(1:nrow(rm_outlier_amp), function(x){
if(rm_outlier_amp$ID[x] == 0) weight <- NA else {
if (rm_outlier_amp$year[x] == 2019)
sub_lift <- lift[grep("\\.2019\\.", lift$Video), ] else
sub_lift <- lift[grep("\\.2021\\.", lift$Video), ]
weights <- sub_lift$Weight[sub_lift$ID == rm_outlier_amp$ID[x]]
if (length(weights) > 0)
# get the mean of the 2 highest flights
weight <- mean(sort(weights, decreasing = TRUE)[1:2]) else
weight <- NA
}
return(weight)
})
# read vegetation density
veg <- read_excel(path = "./data/raw/Vegetation_density_lbh.xlsx")
veg$mean_count <- apply(veg[, c("N", "S", "W", "E")], 1, mean, na.rm = TRUE)
# divide by 16 (max number of lines on pole)
veg$veg_density <- 1 - veg$mean_count / 16
agg_veg <- aggregate(veg_density ~ ID, veg, mean)
rm_outlier_amp$veg_density <- sapply(1:nrow(rm_outlier_amp), function(x) agg_veg$veg_density[agg_veg$ID == as.numeric(rm_outlier_amp$ID[x])][1])
# subset data
body_size_data <- rm_outlier_amp[rm_outlier_amp$Treatment == "Regular_singing" & rm_outlier_amp$year == 2021 & !is.na(rm_outlier_amp$PC1) & !is.na(rm_outlier_amp$lift.weight) & rm_outlier_amp$period == "morning", ]
# subset data
body_size_data <- rm_outlier_amp[rm_outlier_amp$Treatment == "Regular_singing" & rm_outlier_amp$year == 2021 & !is.na(rm_outlier_amp$PC1) & !is.na(rm_outlier_amp$lift.weight) & rm_outlier_amp$period == "morning", ]
str(body_size_data)
size_mods <- pblapply(size_formulas, function(x){
replicate(n = 3, MCMCglmm(as.formula(x), random = ~ ID + songtype, data = body_size_data, verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE)), simplify = FALSE)
})
# model SPL by body condition
size_formulas <- c("cal.spl ~ 1", "cal.spl ~ PC1", "cal.spl ~ lift.weight", "cal.spl ~ lift.weight + PC1", "cal.spl ~ lift.weight *  PC1", "cal.spl ~ veg_density", "cal.spl ~ PC1 + veg_density", "cal.spl ~ lift.weight + veg_density", "cal.spl ~ lift.weight + PC1 + veg_density", "cal.spl ~ lift.weight *  PC1 * veg_density")
size_mods <- pblapply(size_formulas, function(x){
replicate(n = 3, MCMCglmm(as.formula(x), random = ~ ID + songtype, data = body_size_data, verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE)), simplify = FALSE)
})
size_mods <- pblapply(size_formulas, cl = 8, function(x){
replicate(n = 3, MCMCglmm(as.formula(x), random = ~ ID + songtype, data = body_size_data, verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE)), simplify = FALSE)
})
names(size_mods) <- gsub("cal.spl ~ ", "", size_formulas)
saveRDS(list(size_formulas = size_formulas, size_mods = size_mods), "./output/mcmcglmm_size_models.RDS")
attach(readRDS("./output/mcmcglmm_size_models.RDS"))
mod_list <- lapply(size_mods, "[[", 1)
names(mod_list) <- gsub("cal.spl ~ ", "", size_formulas)
model_selection <- model.sel(mod_list, rank="DIC")
model_selection
model_selection
names(model_selection)
model_selection[grep("(Intercept)|family|df|DIC|logLik", names(model_selection)), ]
model_selection[grep("(Intercept)|family|df|DIC|logLik", names(model_selection), invert = TRUE), ]
model_selection[, grep("(Intercept)|family|df|DIC|logLik", names(model_selection), invert = TRUE)]
model_selection[, grep("(Intercept)|family|df|logLik", names(model_selection), invert = TRUE)]
model_selection[, grep("(Intercept)|family|df|DIC", names(model_selection), invert = TRUE)]
model_selection <- as.data.frame(model_selection)
model_selection[, grep("(Intercept)|family|df|DIC|logLik", names(model_selection), invert = TRUE)]
# how predictors covary
body_size_sub <- body_size_data[!duplicated(body_size_data$lift.weight), ]
names(body_size_sub)
cor(body_size_sub[, c("lift.weight", "veg_density", "PC1")])
cor(body_size_sub[, c("lift.weight", "veg_density", "PC1", "weight")])
md <- MCMCglmm(veg_density ~ lift.weight + PC1 + weight, random = ~ ID + songtype, data = body_size_sub, verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE))
md <- MCMCglmm(veg_density ~ lift.weight + PC1, random = ~ ID + songtype, data = body_size_sub, verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE))
md <- MCMCglmm(veg_density ~ lift.weight + PC1, random = ~ ID + lek, data = body_size_sub, verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE))
md <- MCMCglmm(veg_density ~ lift.weight + PC1, random = ~ lek, data = body_size_sub, verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE))
summary(md)
md <- MCMCglmm(veg_density ~ lift.weight + PC1 + weight, random = ~ lek, data = body_size_sub, verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE))
summary(md)
